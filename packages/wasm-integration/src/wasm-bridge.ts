/**
 * WASM Bridge Integration
 * Universal bridge between JavaScript and WebAssembly coordination system
 */

import { EventEmitter } from 'events';
import { v4 as uuidv4 } from 'uuid';

// Import the WASM module (generated by wasm-pack)
import * as wasm from '../pkg/nodejs/wasm_swarm_coordinator.js';

export interface WasmCoordinatorConfig {
  maxAgents: number;
  enablePerformanceOptimization: boolean;
  enableMemoryOptimization: boolean;
  logLevel: 'debug' | 'info' | 'warn' | 'error';
}

export interface WasmAgent {
  id: string;
  type: string;
  name: string;
  capabilities: string[];
  status: 'active' | 'idle' | 'busy' | 'error';
  performance: number;
  memoryUsage: number;
}

export interface WasmTask {
  id: string;
  name: string;
  priority: number;
  status: 'pending' | 'in_progress' | 'completed' | 'failed';
  assignedAgent?: string;
  dependencies: string[];
  progress: number;
  startTime?: number;
  endTime?: number;
}

export interface WasmSwarmStatus {
  activeAgents: number;
  totalTasks: number;
  completedTasks: number;
  averageResponseTime: number;
  memoryUsage: number;
  cpuUsage: number;
  throughput: number;
}

export class WasmSwarmCoordinator extends EventEmitter {
  private wasmInstance: any;
  private config: WasmCoordinatorConfig;
  private agents: Map<string, WasmAgent> = new Map();
  private tasks: Map<string, WasmTask> = new Map();
  private isInitialized: boolean = false;
  private performanceMonitor: NodeJS.Timer | null = null;

  constructor(config: WasmCoordinatorConfig) {
    super();
    this.config = config;
    this.initialize();
  }

  private async initialize(): Promise<void> {
    try {
      // Initialize WASM module
      await wasm.default();
      this.wasmInstance = new wasm.WasmSwarmCoordinator(this.config.maxAgents);
      
      this.isInitialized = true;
      this.startPerformanceMonitoring();
      
      this.emit('initialized', {
        maxAgents: this.config.maxAgents,
        timestamp: Date.now()
      });
    } catch (error) {
      this.emit('error', error);
      throw new Error(`Failed to initialize WASM coordinator: ${error.message}`);
    }
  }

  private startPerformanceMonitoring(): void {
    if (!this.config.enablePerformanceOptimization) return;

    this.performanceMonitor = setInterval(() => {
      this.collectPerformanceMetrics();
    }, 1000);
  }

  private collectPerformanceMetrics(): void {
    if (!this.isInitialized) return;

    try {
      const status = this.getSwarmStatus();
      
      this.emit('metrics', {
        timestamp: Date.now(),
        activeAgents: status.activeAgents,
        memoryUsage: status.memoryUsage,
        cpuUsage: status.cpuUsage,
        throughput: status.throughput
      });

      // Auto-optimize if thresholds exceeded
      if (status.memoryUsage > 80 || status.cpuUsage > 85) {
        this.optimizePerformance();
      }
    } catch (error) {
      this.emit('error', error);
    }
  }

  public async spawnAgent(
    type: string,
    name: string,
    capabilities: string[]
  ): Promise<string> {
    if (!this.isInitialized) {
      throw new Error('WASM coordinator not initialized');
    }

    try {
      const agentId = this.wasmInstance.spawn_agent(
        type,
        name,
        JSON.stringify(capabilities)
      );

      if (!agentId) {
        throw new Error('Failed to spawn agent in WASM');
      }

      const agent: WasmAgent = {
        id: agentId,
        type,
        name,
        capabilities,
        status: 'active',
        performance: 100,
        memoryUsage: 0
      };

      this.agents.set(agentId, agent);
      
      this.emit('agent:spawned', {
        agent,
        timestamp: Date.now()
      });

      return agentId;
    } catch (error) {
      this.emit('error', error);
      throw error;
    }
  }

  public async createTask(
    name: string,
    priority: number,
    dependencies: string[] = []
  ): Promise<string> {
    if (!this.isInitialized) {
      throw new Error('WASM coordinator not initialized');
    }

    try {
      const taskId = this.wasmInstance.create_task(
        name,
        priority,
        JSON.stringify(dependencies)
      );

      if (!taskId) {
        throw new Error('Failed to create task in WASM');
      }

      const task: WasmTask = {
        id: taskId,
        name,
        priority,
        status: 'pending',
        dependencies,
        progress: 0,
        startTime: Date.now()
      };

      this.tasks.set(taskId, task);
      
      this.emit('task:created', {
        task,
        timestamp: Date.now()
      });

      return taskId;
    } catch (error) {
      this.emit('error', error);
      throw error;
    }
  }

  public async assignTask(taskId: string, agentId: string): Promise<boolean> {
    if (!this.isInitialized) {
      throw new Error('WASM coordinator not initialized');
    }

    try {
      const success = this.wasmInstance.assign_task(taskId, agentId);
      
      if (success) {
        // Update local state
        const task = this.tasks.get(taskId);
        const agent = this.agents.get(agentId);
        
        if (task && agent) {
          task.assignedAgent = agentId;
          task.status = 'in_progress';
          agent.status = 'busy';
          
          this.tasks.set(taskId, task);
          this.agents.set(agentId, agent);
          
          this.emit('task:assigned', {
            taskId,
            agentId,
            timestamp: Date.now()
          });
        }
      }

      return success;
    } catch (error) {
      this.emit('error', error);
      throw error;
    }
  }

  public async completeTask(taskId: string, result: any): Promise<boolean> {
    if (!this.isInitialized) {
      throw new Error('WASM coordinator not initialized');
    }

    try {
      const success = this.wasmInstance.update_task_status(taskId, 'completed');
      
      if (success) {
        const task = this.tasks.get(taskId);
        
        if (task) {
          task.status = 'completed';
          task.progress = 100;
          task.endTime = Date.now();
          
          // Update agent status
          if (task.assignedAgent) {
            const agent = this.agents.get(task.assignedAgent);
            if (agent) {
              agent.status = 'idle';
              
              // Update performance based on completion time
              if (task.startTime && task.endTime) {
                const duration = task.endTime - task.startTime;
                const expectedDuration = this.getExpectedDuration(task.priority);
                const performanceRatio = expectedDuration / duration;
                agent.performance = Math.min(100, agent.performance * 0.9 + performanceRatio * 10);
              }
              
              this.agents.set(task.assignedAgent, agent);
            }
          }
          
          this.tasks.set(taskId, task);
          
          this.emit('task:completed', {
            task,
            result,
            timestamp: Date.now()
          });
        }
      }

      return success;
    } catch (error) {
      this.emit('error', error);
      throw error;
    }
  }

  public getSwarmStatus(): WasmSwarmStatus {
    if (!this.isInitialized) {
      throw new Error('WASM coordinator not initialized');
    }

    try {
      const rawStatus = this.wasmInstance.get_swarm_status();
      const status = JSON.parse(rawStatus);
      
      return {
        activeAgents: this.agents.size,
        totalTasks: this.tasks.size,
        completedTasks: Array.from(this.tasks.values()).filter(t => t.status === 'completed').length,
        averageResponseTime: this.calculateAverageResponseTime(),
        memoryUsage: this.calculateMemoryUsage(),
        cpuUsage: this.calculateCpuUsage(),
        throughput: this.calculateThroughput()
      };
    } catch (error) {
      this.emit('error', error);
      throw error;
    }
  }

  private calculateAverageResponseTime(): number {
    const completedTasks = Array.from(this.tasks.values()).filter(t => 
      t.status === 'completed' && t.startTime && t.endTime
    );
    
    if (completedTasks.length === 0) return 0;
    
    const totalTime = completedTasks.reduce((sum, task) => 
      sum + (task.endTime! - task.startTime!), 0
    );
    
    return totalTime / completedTasks.length;
  }

  private calculateMemoryUsage(): number {
    // Get memory usage from WASM
    const memoryPages = (this.wasmInstance as any).memory?.buffer?.byteLength || 0;
    return (memoryPages / (1024 * 1024)) * 100 / 256; // Percentage of 256MB
  }

  private calculateCpuUsage(): number {
    // Simple CPU usage approximation based on active agents
    const activeAgents = Array.from(this.agents.values()).filter(a => a.status === 'busy').length;
    return (activeAgents / this.config.maxAgents) * 100;
  }

  private calculateThroughput(): number {
    // Tasks completed per minute
    const completedTasks = Array.from(this.tasks.values()).filter(t => t.status === 'completed');
    const now = Date.now();
    const oneMinuteAgo = now - 60000;
    
    const recentCompletions = completedTasks.filter(t => 
      t.endTime && t.endTime > oneMinuteAgo
    ).length;
    
    return recentCompletions;
  }

  private getExpectedDuration(priority: number): number {
    // Expected duration based on priority (higher priority = shorter expected duration)
    const baseDuration = 60000; // 1 minute
    return baseDuration / Math.max(1, priority);
  }

  public async optimizePerformance(): Promise<void> {
    if (!this.config.enablePerformanceOptimization) return;

    try {
      // Memory optimization
      if (this.config.enableMemoryOptimization) {
        await this.optimizeMemory();
      }

      // Load balancing
      await this.balanceLoad();

      // Garbage collection
      await this.performGarbageCollection();

      this.emit('performance:optimized', {
        timestamp: Date.now(),
        optimizations: ['memory', 'load-balancing', 'garbage-collection']
      });
    } catch (error) {
      this.emit('error', error);
    }
  }

  private async optimizeMemory(): Promise<void> {
    // Clean up completed tasks older than 1 hour
    const oneHourAgo = Date.now() - 3600000;
    const tasksToRemove = Array.from(this.tasks.entries()).filter(([_, task]) => 
      task.status === 'completed' && task.endTime && task.endTime < oneHourAgo
    );

    for (const [taskId, _] of tasksToRemove) {
      this.tasks.delete(taskId);
    }
  }

  private async balanceLoad(): Promise<void> {
    // Redistribute tasks from overloaded agents
    const overloadedAgents = Array.from(this.agents.values()).filter(a => a.status === 'busy');
    const idleAgents = Array.from(this.agents.values()).filter(a => a.status === 'idle');

    if (overloadedAgents.length > 0 && idleAgents.length > 0) {
      // Simple load balancing logic
      const pendingTasks = Array.from(this.tasks.values()).filter(t => t.status === 'pending');
      
      for (const task of pendingTasks.slice(0, idleAgents.length)) {
        const bestAgent = idleAgents.find(a => 
          a.capabilities.some(cap => task.name.toLowerCase().includes(cap.toLowerCase()))
        ) || idleAgents[0];
        
        if (bestAgent) {
          await this.assignTask(task.id, bestAgent.id);
        }
      }
    }
  }

  private async performGarbageCollection(): Promise<void> {
    // Force garbage collection in WASM if supported
    if (typeof (globalThis as any).gc === 'function') {
      (globalThis as any).gc();
    }
  }

  public storeMemory(key: string, value: string): boolean {
    if (!this.isInitialized) {
      throw new Error('WASM coordinator not initialized');
    }

    return this.wasmInstance.store_memory(key, value);
  }

  public retrieveMemory(key: string): string {
    if (!this.isInitialized) {
      throw new Error('WASM coordinator not initialized');
    }

    return this.wasmInstance.retrieve_memory(key);
  }

  public getAgents(): WasmAgent[] {
    return Array.from(this.agents.values());
  }

  public getTasks(): WasmTask[] {
    return Array.from(this.tasks.values());
  }

  public async shutdown(): Promise<void> {
    if (this.performanceMonitor) {
      clearInterval(this.performanceMonitor);
      this.performanceMonitor = null;
    }

    this.isInitialized = false;
    this.agents.clear();
    this.tasks.clear();
    
    this.emit('shutdown', {
      timestamp: Date.now()
    });
  }
}

// Factory function for easy instantiation
export function createWasmCoordinator(config: Partial<WasmCoordinatorConfig> = {}): WasmSwarmCoordinator {
  const defaultConfig: WasmCoordinatorConfig = {
    maxAgents: 25,
    enablePerformanceOptimization: true,
    enableMemoryOptimization: true,
    logLevel: 'info'
  };

  return new WasmSwarmCoordinator({ ...defaultConfig, ...config });
}

// Export types for use in other packages
export type {
  WasmCoordinatorConfig,
  WasmAgent,
  WasmTask,
  WasmSwarmStatus
};